#define _CRT_SECURE_NO_WARNINGS 1

/*
Gzip：LZ77从重复语句层面压缩+huffman从字节层面进行压缩

LZ77原来方式：将重复语句替换成更短的<长度，距离，先行缓冲区匹配字符串的下一个字符>，但这样意味着先行缓冲区的下一个字符不参与匹配

Gzip中的LZ77：<长度，距离对>
长度：1个字节表示范围是[0,255]，不会有字符串的长度超过255，所以用1个字节存储
距离对：理论上是在整个查找缓冲区找匹配但因为重复具有局部原理性，重复的字符串不会太远，为了避免用查找效率换匹配率，真正的 匹配范围 不会超过32K ==》2字节
所以<长度，距离对>一共占了3个字节
MIN_MATCH_LEN=3;  MAX_MATCH_LEN=258;

除此以外，
程序中必须要有一块缓冲区(64K)：一个查找缓冲区+ 一个先行缓冲区
(1)查找缓冲区:WSIZE1=32K
     a.该部分数据已经写入压缩文件
	 b.待压缩数据对应的字符串要在该区域里找匹配
	 c.随着压缩进行，查找缓冲区在不断增大
	 
(2)先行缓冲区:WSIZE2=32K
     a.该部分数据是带压缩的数据
	 b.每次在该区域里取得一个字符串，在查找缓冲区找匹配
	 c.随着压缩进行，先行缓冲区在不断缩小
(3)一个比特位标记数组
     用来标记当前是原字符还是

压缩：
1.暴力查找：三个三个字符串进行匹配，效率低
2.哈希
   (1)如果当前字符在缓冲区未找到，
     一直往后遍历，把每个字符直接写入到压缩文件，同时查找缓冲区滑动至这个字符串的结尾，比特位数组依次置0
   (2)如果当前字符在缓冲区找到，
     则与这个字符比对，同时往后遍历，找到匹配的字符串
     在查找缓冲区内选择一个匹配度最高的字符串进行对比，记录下该字符串首字母至对比字符串首字母经过的字符数，和该字符串的长度
	 字符数的对应的比特位数组置1

解压缩：
1.读取标记信息
2.
  如果比特位是0，则直接将压缩文件中的字符写出来
  如果比特位是1，则读取该比特位后面一个比特位，根据这两个比特位对应的数字，来获取这段代表的字符串

*/


int main()
{
	system("pause");
	return 0;
}
