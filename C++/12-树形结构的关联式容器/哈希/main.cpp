#define _CRT_SECURE_NO_WARNINGS 1

/*哈希算法：
哈希冲突：不同的元素通过哈希函数计算出相同的哈希地址，导致多个元素要插同一位置引起冲突 
         解决方法：
		           1.设计一个合理哈希函数(直接定值法和除留余数法)但是不能从根本上解决。
		           2.闭散列：从发生哈希冲突的位置开始，找下一个空位置 
		             找空位置方法：(1) 线性探测：从当前位置依次往后找
					                      优点：处理哈希冲突方式比较简单
										  缺点：一旦发生冲突，容易造成数据的堆积
										  解决：二次探测
					  (2)非线性探测
				          二次探测：从当前位置，不采用依次往后查找  H(i)=H(0)+i^2,H(i+1)=H(0)+(i+1)^2，相减：H(i+1)=H(i)+2*i+1
					  末尾：%表容量，保证每次是不同的位置；不能置0，会引起无休止的探测
		           3.开散列
				   采用哈希桶 (1)计算当前元素所在桶号
				              (2)在桶号对应链表查看看桶号位置是否有元素，无则直接插入，有则往下遍历该桶号对应链表，直到找到空位置
					      (3)插入元素

(1)线性探测：
 1.插入：
   a.通过哈希函数计算元素在哈希表中的位置
   b.如果当前位置状态不为empty：
	  (1)状态为exist，且当前位置数值与插入元素数值相同，直接返回
	  (2)状态为delete或为exist，则线性探测，依次往后遍历查找，知道找到empty的位置为止
   c.插入元素
 2.查找：
   a.通过哈希函数计算元素在哈希表中的位置
   b.如果当前状态不为empty：
	   (1)如果状态为EXIST且元素相同，返回当前下标
	   (2)如果状态为EEXIST且data不同 或者 状态为DELETE，继续往后探测

3.删除：
  a.通过哈希函数计算元素在哈希表中的位置
  b.判断当前位置是否=被删除元素
       是---删除
	   不是---继续向后探测
*/
#include "hashtable.h"
int main()
{
	TestHashTable();
	system("pause");
	return 0;
}
